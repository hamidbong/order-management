def buildResults = [:]
def buildState = [:]

pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    BUILD_STATE_FILE = '.build-state.json'
  }

  stages {
    stage('Préparation') {
      steps {
        script {
          try {
            step([
              $class: 'CopyArtifact',
              projectName: env.JOB_NAME,
              selector: lastSuccessful(),
              filter: env.BUILD_STATE_FILE,
              target: '.',
              flatten: true
            ])
            echo "✅ Artefact récupéré avec succès"
          } catch (Exception e) {
            echo "⚠️ Impossible de restaurer l'artefact : ${e.message}"
          }

          buildState.branch = env.BRANCH_NAME
          buildState.buildNumber = env.BUILD_NUMBER
          buildState.buildUrl = env.BUILD_URL
          buildState.timestamp = new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
          buildState.services = [:]
          buildState.previousState = [:]

          if (fileExists(env.BUILD_STATE_FILE)) {
            try {
              def content = readFile(env.BUILD_STATE_FILE).trim()
              if (content && !content.allWhitespace) {
                echo "Contenu précédent:\n${content}"
                def parsed = new groovy.json.JsonSlurper().parseText(content)
                def deepCopy = new groovy.json.JsonSlurper().parseText(
                  groovy.json.JsonOutput.toJson(parsed)
                ) as Map
                buildState.previousState = deepCopy.previousState ?: [:]
                echo "✅ État précédent chargé"
              } else {
                echo "⚠️ Fichier d'état vide"
              }
            } catch (Exception e) {
              echo "⚠️ Erreur parsing JSON : ${e.getMessage()}"
            }
          } else {
            echo "ℹ️ Aucun fichier d'état trouvé"
          }

          // 🔐 Détection sécurisée des fichiers changés
          def changedFiles = []
          try {
            def gitPrevious = sh(script: 'git rev-parse HEAD~1 || echo HEAD', returnStdout: true).trim()
            def gitCurrent = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
            def diffOutput = sh(
              script: "git diff --name-only ${gitPrevious} ${gitCurrent} || echo ''",
              returnStdout: true
            ).trim()
            changedFiles = diffOutput ? diffOutput.split('\n').findAll { it.trim() } : []
            echo "🔍 Fichiers modifiés : ${changedFiles}"
          } catch (Exception e) {
            echo "⚠️ Erreur détection changements : ${e.getMessage()}"
            changedFiles = []
          }

          // 🔐 Sélection sécurisée des services à builder
          def affectedServices = []
          try {
            def services = env.SERVICES.split(',').collect { it.trim() } as Set
            affectedServices = services.findAll { service ->
              changedFiles.any { file -> file.startsWith("${service}/") }
            } as Set

            if (buildState.previousState?.services instanceof Map) {
              def previouslyFailed = buildState.previousState.services.findAll { k, v ->
                v?.status == 'FAILURE'
              }?.keySet()
              affectedServices.addAll(previouslyFailed)
            }

            echo "🚀 Services à builder : ${affectedServices}"
            env.AFFECTED_SERVICES = affectedServices.join(',')
          } catch (Exception e) {
            echo "⚠️ Erreur calcul services : ${e.message}"
            env.AFFECTED_SERVICES = ''
          }
        }
      }
    }

    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }.findAll { it }

          if (servicesToBuild.isEmpty()) {
            echo "ℹ️ Aucun service à builder"
          } else {
            servicesToBuild.each { service ->
              echo "🚀 Déclenchement du job pour ${service}"
              def buildResult = build job: "${service}/main",
                                     wait: true,
                                     propagate: false,
                                     parameters: []

              def result = "${buildResult.result}"
              echo "🔎 Résultat ${service} : ${result}"

              buildResults[service] = result
              buildState.services[service] = [
                status: result,
                buildNumber: buildResult.number,
                buildUrl: buildResult.absoluteUrl,
                timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
              ]
            }
          }

          // ✅ Sauvegarde de previousState pour la prochaine exécution
          buildState.previousState = [
            services: buildState.services
          ]

          try {
            def jsonContent = groovy.json.JsonOutput.prettyPrint(
              groovy.json.JsonOutput.toJson(buildState)
            )
            writeFile file: env.BUILD_STATE_FILE, text: jsonContent
            echo "✅ État sauvegardé dans ${env.BUILD_STATE_FILE}"
          } catch (Exception e) {
            echo "❌ Erreur écriture état : ${e.getMessage()}"
          }
        }
      }
    }
  }

  post {
    failure {
      echo "❌ Pipeline orchestrateur échoué."
    }

    always {
      archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
      echo "📝 Résumé des builds :"
      script {
        if (buildResults instanceof Map && !buildResults.isEmpty()) {
          buildResults.each { service, result ->
            echo "🔎 ${service} : ${result}"
          }

          def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
          def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
          def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }

          echo "📊 TOTAL: ${buildResults.size()}, SUCCÈS: ${successCount}, ÉCHECS: ${failureCount}, ABANDONNÉS: ${abortedCount}"
        } else {
          echo "ℹ️ Aucun résultat de build à afficher."
        }

        if (fileExists(env.BUILD_STATE_FILE)) {
          echo "📂 Contenu du fichier d'état :"
          echo readFile(env.BUILD_STATE_FILE)
        }
      }
    }
  }
}
