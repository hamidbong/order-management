def buildResults = [:]
def buildState = [:]

pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    BUILD_STATE_FILE = '.build-state.json'
  }
  
  stages {
    stage('Préparation') {
      steps {
        script {
          // Initialiser buildState avec la structure de base
          buildState = [
            branch: env.BRANCH_NAME,
            buildNumber: env.BUILD_NUMBER,
            buildUrl: env.BUILD_URL,
            timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            services: [:]
          ]
          
          // Charger l'état précédent si le fichier existe (méthode alternative)
          if (fileExists(env.BUILD_STATE_FILE)) {
            def previousContent = readFile(env.BUILD_STATE_FILE)
            // Utilisation d'un outil externe pour parser le JSON si nécessaire
            buildState.previousState = new groovy.json.JsonSlurper().parseText(previousContent)
          }
          
          // Détection des changements
          def changedFiles = []
          try {
            changedFiles = sh(
              script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
              returnStdout: true
            ).trim().split('\n')
          } catch (Exception e) {
            echo "⚠️ Impossible de détecter les changements: ${e.message}"
          }

          echo "🔍 Fichiers modifiés : ${changedFiles}"

          def services = env.SERVICES.split(',').collect { it.trim() } as Set
          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set

          // Ajouter les services précédemment en échec
          if (buildState.previousState?.services) {
            def previouslyFailed = buildState.previousState.services.findAll { 
              k, v -> v.status == 'FAILURE' 
            }.keySet()
            affectedServices.addAll(previouslyFailed)
          }

          echo "🚀 Services à builder : ${affectedServices}"
          env.AFFECTED_SERVICES = affectedServices.join(',')
        }
      }
    }

    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }

          servicesToBuild.each { service ->
            if (service) {
              echo "🚀 Déclenchement du job Jenkins pour ${service}"

              def buildResult = build job: "${service}/main",
                                   wait: true,
                                   propagate: false,
                                   parameters: []

              echo "🔎 Résultat du job ${service} : ${buildResult.result}"
              
              // Enregistrer le résultat
              buildResults[service] = buildResult.result
              buildState.services[service] = [
                status: buildResult.result,
                buildNumber: buildResult.number,
                buildUrl: buildResult.absoluteUrl,
                timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
              ]
            }
          }
          
          // Écrire le fichier d'état (méthode alternative)
          writeFile file: env.BUILD_STATE_FILE, 
                   text: groovy.json.JsonOutput.toJson(buildState)
        }
      }
    }
  }

  post {
    failure {
      echo "❌ Pipeline orchestrateur échoué."
    }

    always {
      // Archive le fichier d'état comme artefact
      archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
      
      // Affichage du résumé
      echo "📝 Résumé des builds:"
      script {
        buildResults.each { service, result ->
          echo "🔎 ${service} : ${result}"
        }
        
        def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
        def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
        echo "📊 TOTAL: ${buildResults.size()}, SUCCÈS: ${successCount}, ÉCHECS: ${failureCount}"
      }
    }
  }
}
