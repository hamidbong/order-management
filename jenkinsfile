pipeline {
  agent any

  environment {
    SERVICES = 'order-service,user-service'
    STATE_FILE = '.build-state.json'
  }

  stages {
    stage('Lire l\'√©tat pr√©c√©dent') {
      steps {
        script {
          def stateFile = "${env.STATE_FILE}"
          if (fileExists(stateFile)) {
            def jsonText = readFile(stateFile).trim()
            if (jsonText) {
              buildState = new groovy.json.JsonSlurperClassic().parseText(jsonText)
              } else {
                buildState = [:]  // Initialise l‚Äô√©tat vide si le fichier est vide
                }
                } else {
                  buildState = [:]  // Initialise l‚Äô√©tat vide si le fichier n‚Äôexiste pas
                  }



          /*def stateFile = "${env.STATE_FILE}"
          if (fileExists(stateFile)) {
            def jsonText = readFile(stateFile)
            buildState = new groovy.json.JsonSlurperClassic().parseText(jsonText)
          } else {
            // Initialise l‚Äô√©tat vide
            buildState = [:]
          }*/
          echo "üíæ √âtat pr√©c√©dent : ${buildState}"
          env.BUILD_STATE = groovy.json.JsonOutput.toJson(buildState)
        }
      }
    }

    stage('Pr√©paration') {
      steps {
        script {
          def changedFiles = sh(
            script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
            returnStdout: true
          ).trim().split('\n')

          echo "üîç Fichiers modifi√©s : ${changedFiles}"

          def affectedServices = []
          def services = env.SERVICES.split(',')

          changedFiles.each { file ->
            services.each { service ->
              if (file.startsWith("${service}/")) {
                affectedServices << service
              }
            }
          }

          affectedServices = affectedServices.unique()

          // Ajoute les services en √©chec au build m√™me si pas de modif
          def previousState = new groovy.json.JsonSlurperClassic().parseText(env.BUILD_STATE)
          services.each { service ->
            if (previousState[service] == 'FAILURE' && !affectedServices.contains(service)) {
              echo "‚ö†Ô∏è Ajout du service ${service} car il a √©chou√© pr√©c√©demment."
              affectedServices << service
            }
          }

          echo "üöÄ Services √† builder : ${affectedServices}"
          env.AFFECTED_SERVICES = affectedServices.join(',')
        }
      }
    }

    stage('D√©clencher les jobs') {
      steps {
        script {
          def affectedServices = env.AFFECTED_SERVICES.split(',')
          def buildResults = [:]

          affectedServices.each { service ->
            echo "üöÄ D√©clenchement du job Jenkins pour ${service}"

            def buildResult = build job: "${service}",
                                     wait: true,
                                     propagate: false,
                                     parameters: []

            echo "üîé R√©sultat du job ${service} : ${buildResult.result}"
            buildResults[service] = buildResult.result
          }

          // Mettre √† jour l'√©tat global
          def updatedState = new groovy.json.JsonSlurperClassic().parseText(env.BUILD_STATE)
          buildResults.each { service, result ->
            updatedState[service] = result
          }

          // √âcrire l'√©tat dans le fichier JSON
          writeFile file: "${env.STATE_FILE}", text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(updatedState))
          archiveArtifacts artifacts: "${env.STATE_FILE}", fingerprint: true

          // V√©rifier si un build a √©chou√©
          def hasFailure = buildResults.values().any { it != 'SUCCESS' }
          if (hasFailure) {
            error("‚ùå Un ou plusieurs sous-jobs ont √©chou√© : ${buildResults}")
          } else {
            echo "‚úÖ Tous les jobs ont r√©ussi : ${buildResults}"
          }
        }
      }
    }
  }

  post {
    always {
      echo "üèÅ Pipeline orchestrateur termin√©."
    }
    failure {
      echo "‚ùå Pipeline orchestrateur √©chou√©."
    }
    success {
      echo "‚úÖ Pipeline orchestrateur r√©ussi."
    }
  }
}
