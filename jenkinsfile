pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    //STATE_FILE = '.build-state.json'
    STATE_FILE = ".failed_services_${env.BRANCH_NAME}.txt"
  }
  stages {
    stage('PrÃ©paration') {
      steps {
        script {
          buildResults = [:]  // Reset Ã  chaque exÃ©cution
          // Initialiser la liste des services modifiÃ©s
          def changedFiles = []
          try {
            changedFiles = sh(
              script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
              returnStdout: true
            ).trim().split('\n')
          } catch (Exception e) {
            echo "âš ï¸ Impossible de dÃ©tecter les changements: ${e.message}"
          }

          echo "ðŸ” Fichiers modifiÃ©s : ${changedFiles}"

          // Convertir la liste des services en Set pour Ã©liminer les doublons
          def services = env.SERVICES.split(',').collect { it.trim() } as Set

          // DÃ©tecter les services affectÃ©s
          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set

          // Ajouter les services en Ã©chec
          def failedServices = [] as Set
          if (fileExists("${env.STATE_FILE}")) {
            failedServices = readFile("${env.STATE_FILE}").split('\n')
                          .collect { it.trim() }
                          .findAll { it } as Set // Supprime les lignes vides
          }

          // Combiner les listes en utilisant l'union de Sets
          def allServicesToBuild = (affectedServices + failedServices).toList()

          echo "ðŸš€ Services Ã  builder : ${allServicesToBuild}"
          env.AFFECTED_SERVICES = allServicesToBuild.join(',')
        }
      }
    }
    
    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }
           def buildResults = [:]  // ðŸ› ï¸ Ajout de cette ligne pour initialiser buildResults

          servicesToBuild.each { service ->
           if (service) {
            echo "ðŸš€ DÃ©clenchement du job Jenkins pour ${service}"

            def buildResult = build job: "${service}/main",
                                     wait: true,      // Attend la fin du build
                                     propagate: false, // Ne fait pas Ã©chouer directement le pipeline orchestrateur
                                     parameters: []    // Tu peux passer des paramÃ¨tres si besoin

            echo "ðŸ”Ž RÃ©sultat du job ${service} : ${buildResult.result}"
            buildResults[service] = buildResult.result
            if(buildResults[service] == 'FAILURE'){
              addToFailedFile(service, env.STATE_FILE)
              echo "ðŸ”Ž le job ${service} : ajoutÃ© au fichier des services echouÃ©s, cause ${buildResult.result}"
            }
            else {
              removeFromFailedFile(service, env.STATE_FILE)

            }
           }
            
          }

        }
        script {
          if (buildResults.values().any { it == 'FAILURE' }) {
            currentBuild.result = 'FAILURE'
            echo "âŒ Des builds ont Ã©chouÃ©."
          }
        }

      }
    }
  }
    
  post {
    failure {
      echo "âŒ Pipeline orchestrateur Ã©chouÃ©."
    }

    always {
      echo "ðŸ“ RÃ©sumÃ© des builds:"
      script {
        buildResults.each { service, result ->
          echo "ðŸ”Ž ${service} : ${result}"
        }
      }
    }

  }
}

// Fonctions utilitaires
def addToFailedFile(service, stateFile) {
    def failedServices = [] as Set
    if (fileExists(stateFile)) {
        failedServices = readFile(stateFile).split('\n')
                      .collect { it.trim() }
                      .findAll { it } as Set
    }
    if (!failedServices.contains(service)) {
        writeFile file: stateFile, text: (failedServices + service).toList().join('\n').trim()
    }
}

def removeFromFailedFile(service, stateFile) {
    if (fileExists(stateFile)) {
        def failedServices = readFile(stateFile).split('\n')
                      .collect { it.trim() }
                      .findAll { it } as Set
        failedServices = failedServices - service
        writeFile file: stateFile, text: failedServices.toList().join('\n').trim()
    }
}
