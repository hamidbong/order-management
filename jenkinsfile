pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    BUILD_STATE_FILE = '.build-state.json'
  }

  stages {
    stage('Initialisation') {
      steps {
        script {
          // Initialisation des structures de donnÃ©es
          def buildData = [
            results: [:],
            state: [
              branch: env.BRANCH_NAME,
              buildNumber: env.BUILD_NUMBER,
              buildUrl: env.BUILD_URL,
              timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
              services: [:],
              previousState: [:]
            ]
          ]

          // Sauvegarde initiale des donnÃ©es
          env.BUILD_DATA = groovy.json.JsonOutput.toJson(buildData)
        }
      }
    }

    stage('RÃ©cupÃ©ration Ã©tat prÃ©cÃ©dent') {
      steps {
        script {
          // RÃ©cupÃ©ration des donnÃ©es
          def buildData = new groovy.json.JsonSlurper().parseText(env.BUILD_DATA)

          try {
            // Tentative de rÃ©cupÃ©ration de l'Ã©tat prÃ©cÃ©dent
            step([
              $class: 'CopyArtifact',
              projectName: env.JOB_NAME,
              selector: lastSuccessful(),
              filter: env.BUILD_STATE_FILE,
              target: '.',
              flatten: true
            ])
            echo "âœ… Artefact rÃ©cupÃ©rÃ© avec succÃ¨s"

            if (fileExists(env.BUILD_STATE_FILE)) {
              def content = readFile(env.BUILD_STATE_FILE).trim()
              if (content && !content.allWhitespace) {
                def previousState = new groovy.json.JsonSlurper().parseText(content)
                buildData.state.previousState = previousState.previousState ?: [:]
                echo "âœ… Ã‰tat prÃ©cÃ©dent chargÃ©"
              }
            }
          } catch (Exception e) {
            echo "âš ï¸ Impossible de restaurer l'artefact : ${e.message}"
          }

          // Mise Ã  jour des donnÃ©es
          env.BUILD_DATA = groovy.json.JsonOutput.toJson(buildData)
        }
      }
    }

    stage('DÃ©tection changements') {
      steps {
        script {
          def buildData = new groovy.json.JsonSlurper().parseText(env.BUILD_DATA)
          def changedFiles = []

          try {
            // DÃ©tection des fichiers modifiÃ©s
            def gitPrevious = sh(
              script: 'git rev-parse HEAD~1 2>/dev/null || echo HEAD',
              returnStdout: true
            ).trim()
            
            def gitCurrent = sh(
              script: 'git rev-parse HEAD',
              returnStdout: true
            ).trim()
            
            changedFiles = sh(
              script: "git diff --name-only ${gitPrevious} ${gitCurrent} || echo ''",
              returnStdout: true
            ).trim().split('\n').findAll { it.trim() }

            echo "ğŸ” Fichiers modifiÃ©s dÃ©tectÃ©s: ${changedFiles.size()}"
          } catch (Exception e) {
            echo "âš ï¸ Erreur dÃ©tection changements : ${e.message}"
            currentBuild.result = 'UNSTABLE'
          }

          // DÃ©termination des services affectÃ©s
          try {
            def services = env.SERVICES.split(',').collect { it.trim() }.findAll { it }
            def affectedServices = services.findAll { service ->
              changedFiles.any { file -> file.startsWith("${service}/") }
            } as Set

            // Ajout des services prÃ©cÃ©demment en Ã©chec
            if (buildData.state.previousState?.services instanceof Map) {
              def previouslyFailed = buildData.state.previousState.services.findAll { k, v ->
                v?.status == 'FAILURE'
              }?.keySet()
              affectedServices.addAll(previouslyFailed ?: [])
            }

            env.AFFECTED_SERVICES = affectedServices.join(',')
            echo "ğŸš€ Services Ã  builder: ${affectedServices}"
          } catch (Exception e) {
            echo "âš ï¸ Erreur calcul services : ${e.message}"
            currentBuild.result = 'UNSTABLE'
            env.AFFECTED_SERVICES = ''
          }

          env.BUILD_DATA = groovy.json.JsonOutput.toJson(buildData)
        }
      }
    }

    stage('Construction des services') {
      steps {
        script {
          def buildData = new groovy.json.JsonSlurper().parseText(env.BUILD_DATA)
          def servicesToBuild = env.AFFECTED_SERVICES?.split(',')?.collect { it.trim() }?.findAll { it } ?: []

          if (servicesToBuild.isEmpty()) {
            echo "â„¹ï¸ Aucun service Ã  builder"
          } else {
            // Construction en parallÃ¨le
            def parallelStages = [:]
            
            servicesToBuild.each { service ->
              parallelStages["Build ${service}"] = {
                try {
                  echo "ğŸš€ DÃ©marrage build pour ${service}"
                  
                  def buildResult = build(
                    job: "${service}/main",
                    wait: true,
                    propagate: false,
                    parameters: [],
                    timeout: time(time: 30, unit: 'MINUTES')
                  )
                  
                  // Enregistrement des rÃ©sultats
                  buildData.results[service] = buildResult.result
                  buildData.state.services[service] = [
                    status: buildResult.result,
                    buildNumber: buildResult.number,
                    buildUrl: buildResult.absoluteUrl,
                    timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                  ]
                  
                  echo "ğŸ” RÃ©sultat ${service}: ${buildResult.result}"
                } catch (Exception e) {
                  buildData.results[service] = 'FAILURE'
                  buildData.state.services[service] = [
                    status: 'FAILURE',
                    error: e.message,
                    timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                  ]
                  echo "âŒ Erreur build ${service}: ${e.message}"
                  currentBuild.result = 'FAILURE'
                }
              }
            }
            
            // ExÃ©cution parallÃ¨le
            parallel parallelStages
          }

          // PrÃ©paration pour la prochaine exÃ©cution
          buildData.state.previousState = [
            services: buildData.state.services
          ]

          // Sauvegarde des donnÃ©es
          env.BUILD_DATA = groovy.json.JsonOutput.toJson(buildData)
        }
      }
    }

    stage('Sauvegarde Ã©tat') {
      steps {
        script {
          def buildData = new groovy.json.JsonSlurper().parseText(env.BUILD_DATA)

          // Sauvegarde thread-safe de l'Ã©tat
          lock('build-state-lock') {
            try {
              def jsonContent = groovy.json.JsonOutput.prettyPrint(
                groovy.json.JsonOutput.toJson(buildData.state)
              )
              writeFile file: env.BUILD_STATE_FILE, text: jsonContent
              echo "âœ… Ã‰tat sauvegardÃ© dans ${env.BUILD_STATE_FILE}"
            } catch (Exception e) {
              echo "âŒ Erreur Ã©criture Ã©tat : ${e.getMessage()}"
              currentBuild.result = 'FAILURE'
            }
          }
        }
      }
    }
  }

  post {
    always {
      script {
        def buildData = new groovy.json.JsonSlurper().parseText(env.BUILD_DATA ?: '{}')

        // Archivage des artefacts
        try {
          archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
        } catch (Exception e) {
          echo "âš ï¸ Erreur archivage : ${e.message}"
        }

        // Rapport des rÃ©sultats
        echo "ğŸ“ RÃ©sumÃ© des builds :"
        if (buildData.results) {
          buildData.results.each { service, result ->
            echo "ğŸ” ${service} : ${result}"
          }

          def stats = [
            total: buildData.results.size(),
            success: buildData.results.count { k, v -> v == 'SUCCESS' },
            failure: buildData.results.count { k, v -> v == 'FAILURE' },
            aborted: buildData.results.count { k, v -> v == 'ABORTED' }
          ]

          echo "ğŸ“Š TOTAL: ${stats.total}, SUCCÃˆS: ${stats.success}, Ã‰CHECS: ${stats.failure}, ABANDONNÃ‰S: ${stats.aborted}"
        } else {
          echo "â„¹ï¸ Aucun rÃ©sultat de build Ã  afficher"
        }
      }
    }
  }
}