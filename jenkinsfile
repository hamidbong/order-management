pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    STATE_FILE = '.build-state.json'
  }
  stages {

    stage('Pr√©paration') {
      steps {
        script {
          def changedFiles = sh(
            script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
            returnStdout: true
          ).trim().split('\n')

          echo "üîç Fichiers modifi√©s : ${changedFiles}"

          def affectedServices = []
          def services = env.SERVICES.split(',')

          changedFiles.each { file ->
            services.each { service ->
              if (file.startsWith("${service}/")) {
                affectedServices << service
              }
            }
          }

          affectedServices = affectedServices.unique()

          /*// Ajoute les services en √©chec au build m√™me si pas de modif
          def previousState = new groovy.json.JsonSlurperClassic().parseText(env.BUILD_STATE)
          services.each { service ->
            if (previousState[service] == 'FAILURE' && !affectedServices.contains(service)) {
              echo "‚ö†Ô∏è Ajout du service ${service} car il a √©chou√© pr√©c√©demment."
              affectedServices << service
            }
          }*/

          echo "üöÄ Services √† builder : ${affectedServices}"
          env.AFFECTED_SERVICES = affectedServices.join(',')
        }
      }
    }
    
    stage('Build Microservices') {
      steps {
        script {
          // Lire les services pr√©c√©demment en √©chec
          def affectedServices = env.AFFECTED_SERVICES.split(',')

          def failedServices = []
          if (fileExists('failed_services.txt')) {
            failedServices = readFile('failed_services.txt').split('\n')
          }
          // D√©tecter les services modifi√©s (votre logique actuelle)
          //def changedServices = detectChangedServices()
                
          // Combiner les deux listes (sans doublons)
          def servicesToBuild = (failedServices + affectedServices).unique()
                    
          // Lancer les builds
          servicesToBuild.each { service ->
            try {
              build job: "build-${service}", wait: false
              // Si succ√®s, retirer du fichier d'√©chec si pr√©sent
              removeFromFailedFile(service)
            } catch (e) {
                // Si √©chec, ajouter au fichier d'√©chec
                addToFailedFile(service)
            }
          }
        }
      }
    }
  }
    
    post {
      failure {
        echo "‚ùå Pipeline orchestrateur √©chou√©."
      }
    }
}

// Fonctions utilitaires
def addToFailedFile(service) {
    def failedServices = []
    if (fileExists('failed_services.txt')) {
        failedServices = readFile('failed_services.txt').split('\n')
    }
    if (!failedServices.contains(service)) {
        writeFile file: 'failed_services.txt', text: "${failedServices.join('\n')}\n${service}".trim()
    }
}

def removeFromFailedFile(service) {
    if (fileExists('failed_services.txt')) {
        def failedServices = readFile('failed_services.txt').split('\n')
        failedServices = failedServices - service
        writeFile file: 'failed_services.txt', text: failedServices.join('\n')
    }
}
