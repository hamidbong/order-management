pipeline {
  agent any
  environment {
    DOCKERHUB_CREDENTIALS = 'dockerhub-credentials'
    DOCKERHUB_REPO = 'hamidbong/webapp'
  }
  parameters {
    choice(name: 'SERVICE', choices: ['order-service', 'user-service'], description: 'SÃ©lectionnez le microservice Ã  builder')
  }
  stages {
    stage('Checkout') {
      steps {
        script {
          checkout scm
        }
      }
    }
    
    stage('PrÃ©paration') {
      steps {
        script {
          // Liste les fichiers modifiÃ©s entre la prÃ©cÃ©dente et la nouvelle rÃ©vision
          def changedFiles = sh(
            script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
            returnStdout: true
          ).trim().split('\n')

          echo "Fichiers modifiÃ©s : ${changedFiles}"

          // Initialise la liste des services affectÃ©s
          def affectedServices = []

          // Liste de tes services dans le monorepo
          def services = ['order-service', 'user-service']

          // VÃ©rifie si un fichier modifiÃ© appartient Ã  un des services
          changedFiles.each { file ->
            services.each { service ->
              if (file.startsWith("${service}/")) {
                affectedServices << service
              }
            }
          }

          // Supprime les doublons (au cas oÃ¹)
          affectedServices = affectedServices.unique()
          echo "Services impactÃ©s : ${affectedServices}"

          // Partage la liste pour les autres Ã©tapes
          env.AFFECTED_SERVICES = affectedServices.join(',')
        }
      }
    }

    stage('DÃ©clencher les pipelines des services') {
      steps {
        script {
          def affectedServices = env.AFFECTED_SERVICES.split(',')

          affectedServices.each { service ->
            echo "ðŸš€ DÃ©clenchement du pipeline pour ${service}"

            // Appelle le pipeline Jenkins du service
            // Assure-toi que les jobs Jenkins pour chaque service sont bien crÃ©Ã©s avec les bons noms !
            build job: "${service}", wait: false
          }
        }
      }
    }
    
    stage('Build') {
      steps {
        script {
          if (params.SERVICE == 'order-service') {
            dir('order-service') {
              sh 'npm install'
              sh 'npm run build'
            }
          } else if (params.SERVICE == 'user-service') {
            dir('user-service') {
              sh 'mvn clean package'
            }
          }
        }
      }
    }

    stage('Test') {
      steps {
        script {
          if (params.SERVICE == 'order-service') {
            dir('order-service') {
              sh 'npm test'
            }
          } else if (params.SERVICE == 'user-service') {
            dir('service-java') {
              sh 'mvn test'
            }
          }
        }
      }
    }

    stage('Security Scan') {
      agent {
        docker {
          image 'aquasec/trivy:latest'
          args '-v /var/run/docker.sock:/var/run/docker.sock'
        }
      }
      steps {
        script {
          def imageTag = "${DOCKERHUB_REPO}:${env.SERVICE}-${env.BUILD_NUMBER}"
          sh "docker build -t ${imageTag} ."
          sh "trivy image ${imageTag} || true"
        }
      }
    }

    stage('Docker Build & Push') {
      steps {
        script {
          def imageTag = "${DOCKERHUB_REPO}:${env.SERVICE}-${env.BUILD_NUMBER}"

          docker.withRegistry('https://index.docker.io/v1/', "${DOCKERHUB_CREDENTIALS}") {
            dir("${env.SERVICE}") {
              sh "docker build -t ${imageTag} ."
              sh "docker push ${imageTag}"
            }
          }
          echo "Image poussÃ©e : ${imageTag}"
        }
      }
    }

    stage('Deploy') {
      steps {
        script {
          withCredentials([file(credentialsId: 'KUBECONFIG_PROD', variable: 'KUBECONFIG')]) {
            sh """
              export KUBECONFIG=$KUBECONFIG
              helm upgrade --install ${params.SERVICE} ./helm-chart \
                --set image.repository=${DOCKER_REGISTRY}/${params.SERVICE} \
                --set image.tag=${IMAGE_TAG} \
                --namespace mynamespace \
                --kube-context=${KUBE_CONTEXT}
            """
          }
        }
      }
    }
  }
  post {
    always {
      cleanWs()
    }
  }
}
