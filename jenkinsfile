def buildResults = [:]
def buildState = [:]

pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    BUILD_STATE_FILE = '.build-state.json'
  }

  stages {
    stage('PrÃ©paration') {
      steps {
        script {
          try {
            step([
              $class: 'CopyArtifact',
              projectName: env.JOB_NAME,
              selector: lastSuccessful(),
              filter: env.BUILD_STATE_FILE,
              target: '.',
              flatten: true
            ])
            echo "âœ… Artefact rÃ©cupÃ©rÃ© avec succÃ¨s"
          } catch (Exception e) {
            echo "âš ï¸ Impossible de restaurer l'artefact : ${e.message}"
          }

          // Initialisation de buildState
          buildState = [
            branch: env.BRANCH_NAME,
            buildNumber: env.BUILD_NUMBER,
            buildUrl: env.BUILD_URL,
            timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            services: [:],
            previousState: [:]
          ]

          // Chargement Ã©tat prÃ©cÃ©dent
          if (fileExists(env.BUILD_STATE_FILE)) {
            try {
              def content = readFile(env.BUILD_STATE_FILE).trim()
              if (content && !content.allWhitespace) {
                echo "Contenu prÃ©cÃ©dent:\n${content}"
                // Conversion explicite pour Ã©viter LazyMap
                def parsedJson = new groovy.json.JsonSlurper().parseText(content)
                buildState.previousState = new HashMap(parsedJson)
                echo "âœ… Ã‰tat prÃ©cÃ©dent chargÃ©"
              } else {
                echo "âš ï¸ Fichier d'Ã©tat vide"
              }
            } catch (Exception e) {
              echo "âš ï¸ Erreur parsing JSON : ${e.getMessage()}"
            }
          } else {
            echo "â„¹ï¸ Aucun fichier d'Ã©tat trouvÃ©"
          }

          // DÃ©tection des fichiers changÃ©s
          def changedFiles = []
          try {
            def gitPrevious = sh(script: 'git rev-parse HEAD~1 || echo HEAD', returnStdout: true).trim()
            def gitCurrent = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()

            changedFiles = sh(
              script: "git diff --name-only ${gitPrevious} ${gitCurrent}",
              returnStdout: true
            ).trim().split('\n').findAll { it.trim() }
            echo "ğŸ” Fichiers modifiÃ©s : ${changedFiles}"
          } catch (Exception e) {
            echo "âš ï¸ Erreur dÃ©tection changements : ${e.getMessage()}"
            changedFiles = [] // Assure que changedFiles est toujours une liste
          }

          // Services affectÃ©s
          def services = env.SERVICES.split(',').collect { it.trim() } as Set
          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set

          // Ajouter ceux en Ã©chec prÃ©cÃ©demment
          if (buildState.previousState?.services instanceof Map) {
            def previouslyFailed = buildState.previousState.services.findAll { k, v ->
              v?.status == 'FAILURE'
            }?.keySet()
            if (previouslyFailed) {
              affectedServices.addAll(previouslyFailed)
            }
          }

          echo "ğŸš€ Services Ã  builder : ${affectedServices}"
          env.AFFECTED_SERVICES = affectedServices.join(',')
        }
      }
    }

    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES?.split(',')?.collect { it.trim() }?.findAll { it } ?: []

          if (servicesToBuild.isEmpty()) {
            echo "â„¹ï¸ Aucun service Ã  builder"
          } else {
            servicesToBuild.each { service ->
              echo "ğŸš€ DÃ©clenchement du job pour ${service}"
              try {
                def buildResult = build job: "${service}/main",
                                       wait: true,
                                       propagate: false,
                                       parameters: []

                echo "ğŸ” RÃ©sultat ${service} : ${buildResult.result}"

                buildResults[service] = buildResult.result
                buildState.services[service] = [
                  status: buildResult.result,
                  buildNumber: buildResult.number,
                  buildUrl: buildResult.absoluteUrl,
                  timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                ]
              } catch (Exception e) {
                echo "âŒ Erreur lors du build de ${service}: ${e.message}"
                buildResults[service] = 'FAILURE'
                buildState.services[service] = [
                  status: 'FAILURE',
                  error: e.message,
                  timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                ]
              }
            }
          }

          try {
            def jsonContent = groovy.json.JsonOutput.prettyPrint(
              groovy.json.JsonOutput.toJson(buildState)
            )
            writeFile file: env.BUILD_STATE_FILE, text: jsonContent
            echo "âœ… Ã‰tat sauvegardÃ© dans ${env.BUILD_STATE_FILE}"
          } catch (Exception e) {
            echo "âŒ Erreur Ã©criture Ã©tat : ${e.getMessage()}"
          }
        }
      }
    }
  }

  post {
    failure {
      echo "âŒ Pipeline orchestrateur Ã©chouÃ©."
    }

    always {
      script {
        try {
          // Archiver seulement si le fichier existe
          if (fileExists(env.BUILD_STATE_FILE)) {
            archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
          } else {
            echo "âš ï¸ Fichier d'Ã©tat non trouvÃ© pour archivage"
          }

          echo "ğŸ“ RÃ©sumÃ© des builds :"
          buildResults.each { service, result ->
            echo "ğŸ” ${service} : ${result}"
          }

          def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
          def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
          def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }

          echo "ğŸ“Š TOTAL: ${buildResults.size()}, SUCCÃˆS: ${successCount}, Ã‰CHECS: ${failureCount}, ABANDONNÃ‰S: ${abortedCount}"

          if (fileExists(env.BUILD_STATE_FILE)) {
            echo "ğŸ“‚ Contenu du fichier d'Ã©tat :"
            echo readFile(env.BUILD_STATE_FILE)
          }
        } catch (Exception e) {
          echo "âš ï¸ Erreur dans la section post: ${e.message}"
        }
      }
    }
  }
}