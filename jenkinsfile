def buildResults = [:]

pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    env.STATE_FILE = ".failed_services_main.txt"
  }
  stages {
    stage('Préparation') {
      steps {
        script {
          //env.STATE_FILE = ".failed_services_${env.BRANCH_NAME}.txt"
          

          buildResults.clear()

          def changedFiles = []
          try {
            changedFiles = sh(
              script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
              returnStdout: true
            ).trim().split('\n')
          } catch (Exception e) {
            echo "⚠️ Impossible de détecter les changements: ${e.message}"
          }

          echo "🔍 Fichiers modifiés : ${changedFiles}"

          def services = env.SERVICES.split(',').collect { it.trim() } as Set

          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set

          def failedServices = [] as Set
          if (fileExists(env.STATE_FILE)) {
            failedServices = readFile(env.STATE_FILE).split('\n')
              .collect { it.trim() }
              .findAll { it } as Set
          }

          def allServicesToBuild = (affectedServices + failedServices).toList()

          echo "🚀 Services à builder : ${allServicesToBuild}"
          env.AFFECTED_SERVICES = allServicesToBuild.join(',')
        }
      }
    }

    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }

          servicesToBuild.each { service ->
            if (service) {
              echo "🚀 Déclenchement du job Jenkins pour ${service}"

              def buildResult = build job: "${service}/main",
                                       wait: true,
                                       propagate: false,
                                       parameters: []

              echo "🔎 Résultat du job ${service} : ${buildResult.result}"
              buildResults[service] = buildResult.result
              if (buildResult.result == 'FAILURE') {
                addToFailedFile(service, env.STATE_FILE)
                echo "🔎 ${service} ajouté au fichier des services échoués."
              } else {
                removeFromFailedFile(service, env.STATE_FILE)
              }
            }
          }
        }

        script {
          if (buildResults.values().any { it == 'FAILURE' }) {
            currentBuild.result = 'FAILURE'
            echo "❌ Des builds ont échoué."
          }
        }
      }
    }
  }

  post {
    failure {
      echo "❌ Pipeline orchestrateur échoué."
    }

    always {
      echo "📝 Résumé des builds:"
      script {
        buildResults.each { service, result ->
          echo "🔎 ${service} : ${result}"
        }
      }
    }
  }
}

// Fonctions utilitaires
def addToFailedFile(service, stateFile) {
  echo "🔎 ${service} est le service qui a echoué."
  def failedServices = [] as Set
  if (fileExists(stateFile)) {
    failedServices = readFile(stateFile).split('\n')
      .collect { it.trim() }
      .findAll { it } as Set
  }
  if (!failedServices.contains(service)) {
    writeFile file: stateFile, text: (failedServices + service).toList().join('\n').trim()
  }
}

def removeFromFailedFile(service, stateFile) {
  if (fileExists(stateFile)) {
    def failedServices = readFile(stateFile).split('\n')
      .collect { it.trim() }
      .findAll { it } as Set
    failedServices = failedServices - service
    writeFile file: stateFile, text: failedServices.toList().join('\n').trim()
  }
}
