def buildResults = [:]
def buildState = [:]

pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    BUILD_STATE_FILE = '.build-state.json'
  }

  stages {
    stage('Pr√©paration') {
      steps {
        script {
          // Initialisation des structures de donn√©es
          buildState.branch = env.BRANCH_NAME
          buildState.buildNumber = env.BUILD_NUMBER
          buildState.buildUrl = env.BUILD_URL
          buildState.timestamp = new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
          buildState.services = [:]
          buildState.previousState = [:]


          // 1. R√©cup√©ration de l'√©tat pr√©c√©dent
          try {
            step([
              $class: 'CopyArtifact',
              projectName: env.JOB_NAME,
              selector: lastSuccessful(),
              filter: env.BUILD_STATE_FILE,
              target: '.',
              flatten: true
            ])
            echo "‚úÖ Artefact r√©cup√©r√© avec succ√®s"
          } catch (Exception e) {
            echo "‚ö†Ô∏è Impossible de restaurer l'artefact : ${e.message}"
          }

          // 2. Lecture de l'√©tat pr√©c√©dent
          if (fileExists(env.BUILD_STATE_FILE)) {
            try {
              def content = readFile(env.BUILD_STATE_FILE).trim()
              if (content && !content.allWhitespace) {
                echo "Contenu pr√©c√©dent:\n${content}"
                def parsed = new groovy.json.JsonSlurper().parseText(content)
                // Deep copy pour √©viter les modifications accidentelles
                buildState.previousState = new groovy.json.JsonSlurper().parseText(
                  groovy.json.JsonOutput.toJson(parsed.previousState ?: [:])
                )
                echo "‚úÖ √âtat pr√©c√©dent charg√©"
              } else {
                echo "‚ö†Ô∏è Fichier d'√©tat vide"
              }
            } catch (Exception e) {
              echo "‚ö†Ô∏è Erreur parsing JSON : ${e.getMessage()}"
              currentBuild.result = 'UNSTABLE'
            }
          } else {
            echo "‚ÑπÔ∏è Aucun fichier d'√©tat trouv√©"
          }

          // 3. D√©tection s√©curis√©e des fichiers chang√©s
          def changedFiles = []
          try {
            def gitPrevious = sh(script: 'git rev-parse HEAD~1 2>/dev/null || echo HEAD', returnStdout: true).trim()
            def gitCurrent = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
            def diffOutput = sh(
              script: "git diff --name-only ${gitPrevious} ${gitCurrent} || echo ''",
              returnStdout: true
            ).trim()
            changedFiles = diffOutput ? diffOutput.split('\n').findAll { it.trim() } : []
            echo "üîç Fichiers modifi√©s : ${changedFiles}"
          } catch (Exception e) {
            echo "‚ö†Ô∏è Erreur d√©tection changements : ${e.getMessage()}"
            currentBuild.result = 'UNSTABLE'
            changedFiles = []
          }

          // 4. S√©lection s√©curis√©e des services √† builder
          def affectedServices = []
          try {
            def services = env.SERVICES.split(',').collect { it.trim() }.findAll { it }
            affectedServices = services.findAll { service ->
              changedFiles.any { file -> file.startsWith("${service}/") }
            } as Set

            // Ajout des services pr√©c√©demment en √©chec
            if (buildState.previousState?.services instanceof Map) {
              def previouslyFailed = buildState.previousState.services.findAll { k, v ->
                v?.status == 'FAILURE'
              }?.keySet()
              affectedServices.addAll(previouslyFailed ?: [])
            }

            echo "üöÄ Services √† builder : ${affectedServices}"
            env.AFFECTED_SERVICES = affectedServices.join(',')
          } catch (Exception e) {
            echo "‚ö†Ô∏è Erreur calcul services : ${e.message}"
            currentBuild.result = 'UNSTABLE'
            env.AFFECTED_SERVICES = ''
          }

          // Sauvegarde des donn√©es pour les √©tapes suivantes
          currentBuild.buildResults = buildResults
          currentBuild.buildState = buildState
        }
      }
    }

    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }.findAll { it }

          if (servicesToBuild.isEmpty()) {
            echo "‚ÑπÔ∏è Aucun service √† builder"
          } else {
            // Construction en parall√®le
            def builds = [:]
            servicesToBuild.each { service ->
              builds[service] = {
                try {
                  echo "üöÄ D√©clenchement du job pour ${service}"
                  def buildResult = build(
                    job: "${service}/main",
                    wait: true,
                    propagate: false,
                    parameters: [],
                    timeout: time(time: 30, unit: 'MINUTES')
                  )
                  
                  def result = "${buildResult.result}"
                  echo "üîé R√©sultat ${service} : ${result}"

                  buildResults[service] = result
                  buildState.services[service] = [
                    status: result,
                    buildNumber: buildResult.number,
                    buildUrl: buildResult.absoluteUrl,
                    timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                  ]
                } catch (Exception e) {
                  echo "‚ùå Erreur lors du build de ${service}: ${e.message}"
                  buildResults[service] = 'FAILURE'
                  buildState.services[service] = [
                    status: 'FAILURE',
                    error: e.message,
                    timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
                  ]
                  currentBuild.result = 'FAILURE'
                }
              }
            }
            
            // Ex√©cution en parall√®le avec gestion des erreurs
            try {
              parallel builds
            } catch (Exception e) {
              echo "‚ö†Ô∏è Erreur dans l'ex√©cution parall√®le : ${e.message}"
              currentBuild.result = 'FAILURE'
            }
          }

          // Sauvegarde de l'√©tat pour la prochaine ex√©cution
          buildState.previousState = [
            services: buildState.services
          ]

          // √âcriture s√©curis√©e du fichier d'√©tat
          lock('build-state-lock') {
            try {
              def jsonContent = groovy.json.JsonOutput.prettyPrint(
                groovy.json.JsonOutput.toJson([
                  branch: buildState.branch,
                  buildNumber: buildState.buildNumber,
                  buildUrl: buildState.buildUrl,
                  timestamp: buildState.timestamp,
                  services: buildState.services,
                  previousState: buildState.previousState
                ])
              )
              writeFile file: env.BUILD_STATE_FILE, text: jsonContent
              echo "‚úÖ √âtat sauvegard√© dans ${env.BUILD_STATE_FILE}"
            } catch (Exception e) {
              echo "‚ùå Erreur √©criture √©tat : ${e.getMessage()}"
              currentBuild.result = 'FAILURE'
            }
          }
        }
      }
    }
  }

  post {
    failure {
      echo "‚ùå Pipeline orchestrateur √©chou√©."
    }
    unstable {
      echo "‚ö†Ô∏è Pipeline orchestrateur instable (certaines √©tapes ont eu des probl√®mes)."
    }
    always {
      script {
        // Archivage s√©curis√© de l'artefact
        try {
          archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
        } catch (Exception e) {
          echo "‚ö†Ô∏è Erreur lors de l'archivage : ${e.message}"
        }

        // Affichage du r√©sum√©
        def buildResults = currentBuild.buildResults ?: [:]
        echo "üìù R√©sum√© des builds :"
        if (buildResults instanceof Map && !buildResults.isEmpty()) {
          buildResults.each { service, result ->
            echo "üîé ${service} : ${result}"
          }

          def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
          def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
          def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }

          echo "üìä TOTAL: ${buildResults.size()}, SUCC√àS: ${successCount}, √âCHECS: ${failureCount}, ABANDONN√âS: ${abortedCount}"
        } else {
          echo "‚ÑπÔ∏è Aucun r√©sultat de build √† afficher."
        }

        // Affichage du contenu du fichier d'√©tat
        if (fileExists(env.BUILD_STATE_FILE)) {
          try {
            echo "üìÇ Contenu du fichier d'√©tat :"
            echo readFile(env.BUILD_STATE_FILE)
          } catch (Exception e) {
            echo "‚ö†Ô∏è Erreur lecture fichier d'√©tat : ${e.message}"
          }
        }
      }
    }
  }
}