def buildResults = [:]
def buildState = [:]

pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    BUILD_STATE_FILE = '.build-state.json'
  }
  
  stages {

    stage('Checkout complet') {
      steps {
        checkout([
          $class: 'GitSCM',
          branches: [[name: "*/${env.BRANCH_NAME}"]],
          userRemoteConfigs: [[url: 'https://github.com/hamidbong/order-management.git']],
          doGenerateSubmoduleConfigurations: false,
          extensions: [
            [$class: 'CloneOption', 
              shallow: false, 
              noTags: false, 
              depth: 0, 
              timeout: 10
            ]
          ]
        ])
        
        // Tester que git fonctionne
        script {
          def commit = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
          echo "‚úÖ Commit actuel : ${commit}"
        }
      }
    }

    stage('Pr√©paration') {
      steps {
        script {
          // üîÅ R√©cup√©ration du dernier √©tat sauvegard√© depuis artefact
          try {
            step([
              $class: 'CopyArtifact',
              projectName: env.JOB_NAME,
              selector: lastSuccessful(),
              filter: env.BUILD_STATE_FILE,
              target: '.',
              flatten: true
            ])
            echo "‚úÖ Fichier d‚Äô√©tat restaur√© depuis le dernier build r√©ussi"
          } catch (Exception e) {
            echo "‚ö†Ô∏è Aucune restauration d‚Äô√©tat possible : ${e.message}"
          }

          // Initialisation de l'√©tat du build
          buildState = [
            branch: env.BRANCH_NAME,
            buildNumber: env.BUILD_NUMBER,
            buildUrl: env.BUILD_URL,
            timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            services: [:],
            previousState: [:]
          ]

          // Lecture et parsing s√©curis√© du fichier existant
          if (fileExists(env.BUILD_STATE_FILE)) {
            try {
              def previousContent = readFile(env.BUILD_STATE_FILE).trim()
              if (previousContent && !previousContent.allWhitespace) {
                echo "Contenu du fichier pr√©c√©dent:\n${previousContent}"
                def parsedContent = new groovy.json.JsonSlurper().parseText(previousContent)
                if (parsedContent) {
                  buildState.previousState = parsedContent.collectEntries { k, v -> [(k): v] }
                  echo "‚úÖ √âtat pr√©c√©dent charg√© avec succ√®s"
                } else {
                  echo "‚ö†Ô∏è Fichier JSON pars√© mais vide"
                }
              } else {
                echo "‚ö†Ô∏è Fichier d'√©tat existant mais vide ou ne contenant que des espaces"
              }
            } catch (Exception e) {
              echo "‚ö†Ô∏è Erreur lors du parsing du fichier d'√©tat: ${e.getMessage()}"
            }
          } else {
            echo "‚ÑπÔ∏è Aucun fichier d'√©tat pr√©c√©dent trouv√© (${env.BUILD_STATE_FILE})"
          }

          // üîç D√©tection des changements entre commits
          def changedFiles = []
          def previousCommit = ''
          def currentCommit = ''
          try {
            previousCommit = sh(script: "git rev-parse HEAD~1", returnStdout: true).trim()
            currentCommit = sh(script: "git rev-parse HEAD", returnStdout: true).trim()
            echo "üîÅ Comparaison de ${previousCommit} -> ${currentCommit}"
            changedFiles = sh(
              script: "git diff --name-only ${previousCommit} ${currentCommit}",
              returnStdout: true
            ).trim().split('\n')
          } catch (Exception e) {
            echo "‚ö†Ô∏è Impossible de d√©tecter les changements : ${e.message}"
          }

          echo "üîç Fichiers modifi√©s : ${changedFiles}"

          def services = env.SERVICES.split(',').collect { it.trim() } as Set
          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set

          // Ajouter services en √©chec pr√©c√©demment
          if (buildState.previousState?.services) {
            def previouslyFailed = buildState.previousState.services.findAll { 
              k, v -> v.status == 'FAILURE' 
            }.keySet()
            affectedServices.addAll(previouslyFailed)
          }

          echo "üöÄ Services √† builder : ${affectedServices}"
          env.AFFECTED_SERVICES = affectedServices.join(',')
        }
      }
    }

    stage('Build Microservices') {
      when {
        expression { return env.AFFECTED_SERVICES?.trim() }
      }
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }

          servicesToBuild.each { service ->
            if (service) {
              echo "üöÄ D√©clenchement du job Jenkins pour ${service}"

              def buildResult = build job: "${service}/main",
                                   wait: true,
                                   propagate: false,
                                   parameters: []

              echo "üîé R√©sultat du job ${service} : ${buildResult.result}"

              buildResults[service] = buildResult.result
              buildState.services[service] = [
                status: buildResult.result,
                buildNumber: buildResult.number,
                buildUrl: buildResult.absoluteUrl,
                timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
              ]
            }
          }

          // Sauvegarder le fichier d'√©tat apr√®s build
          try {
            def jsonContent = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(buildState))
            writeFile file: env.BUILD_STATE_FILE, text: jsonContent
            echo "‚úÖ √âtat du build sauvegard√© dans ${env.BUILD_STATE_FILE}"
          } catch (Exception e) {
            echo "‚ùå Erreur lors de l'√©criture du fichier d'√©tat: ${e.getMessage()}"
          }
        }
      }
    }
  }

  post {
    failure {
      echo "‚ùå Pipeline orchestrateur √©chou√©."
    }

    always {
      script {
        try {
          if (buildState.previousState?.isEmpty()) {
            buildState.remove('previousState')
          }

          def jsonContent = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(buildState))
          writeFile file: env.BUILD_STATE_FILE, text: jsonContent
          archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
          echo "üì¶ Contenu final du fichier d'√©tat :\n${jsonContent}"
        } catch (Exception e) {
          echo "‚ùå Erreur critique lors de la sauvegarde finale : ${e.getMessage()}"
        }
      }
    }
  }
}
