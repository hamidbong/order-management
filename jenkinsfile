def buildResults = [:]
def buildState = [services: [:]]

pipeline {
  agent any

  environment {
    SERVICES = 'order-service,user-service'
    BUILD_STATE_FILE = '.build-state.txt'
  }

  stages {
    stage('PrÃ©paration') {
      steps {
        script {
          try {
            step([
              $class: 'CopyArtifact',
              projectName: env.JOB_NAME,
              selector: lastSuccessful(),
              filter: env.BUILD_STATE_FILE,
              target: '.',
              flatten: true
            ])
            echo "âœ… Artefact rÃ©cupÃ©rÃ© avec succÃ¨s"
          } catch (Exception e) {
            echo "âš ï¸ Impossible de restaurer l'artefact : ${e.message}"
          }

          // ğŸ” Charger les services en Ã©chec prÃ©cÃ©dent
          def previousFailures = [] as Set
          if (fileExists(env.BUILD_STATE_FILE)) {
            readFile(env.BUILD_STATE_FILE).trim().split('\n').each { line ->
              def parts = line.split(':', 5)
              if (parts.size() == 5 && parts[1] == 'FAILURE') {
                previousFailures << parts[0]
              }
            }
            echo "âš ï¸ Services Ã©chouÃ©s prÃ©cÃ©demmentt : ${previousFailures}"
          } else {
            echo "â„¹ï¸ Aucun fichier d'Ã©tat trouvÃ©"
          }

          // ğŸ” DÃ©tection des fichiers modifiÃ©s via Git
          def changedFiles = []
          try {
            def gitPrevious = sh(script: 'git rev-parse HEAD~1 || echo HEAD', returnStdout: true).trim()
            def gitCurrent = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
            def diffOutput = sh(script: "git diff --name-only ${gitPrevious} ${gitCurrent} || echo ''", returnStdout: true).trim()
            changedFiles = diffOutput ? diffOutput.split('\n').findAll { it.trim() } : []
            echo "ğŸ” Fichiers modifiÃ©s : ${changedFiles}"
          } catch (Exception e) {
            echo "âš ï¸ Erreur dÃ©tection changements : ${e.message}"
          }

          // ğŸ§  DÃ©terminer les services affectÃ©s
          def services = env.SERVICES.split(',').collect { it.trim() } as Set
          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set
          affectedServices.addAll(previousFailures)

          echo "ğŸš€ Services Ã  builder : ${affectedServices}"
          env.AFFECTED_SERVICES = affectedServices.join(',')
        }
      }
    }

    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }.findAll { it }
          if (servicesToBuild.isEmpty()) {
            echo "â„¹ï¸ Aucun service Ã  builder"
          } else {
            servicesToBuild.each { service ->
              echo "ğŸš€ DÃ©clenchement du job pour ${service}"
              def result = build job: "${service}/main",
                                wait: true,
                                propagate: false,
                                parameters: []

              def status = result.result
              echo "ğŸ” RÃ©sultat ${service} : ${status}"

              buildResults[service] = status
              buildState.services[service] = [
                status: status,
                buildNumber: result.number,
                buildUrl: result.absoluteUrl,
                timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
              ]
            }

            // ğŸ’¾ Sauvegarde de lâ€™Ã©tat sous forme texte
            def lines = buildState.services.collect { svc, info ->
              "${svc}:${info.status}:${info.buildNumber}:${info.buildUrl}:${info.timestamp}"
            }
            writeFile file: env.BUILD_STATE_FILE, text: lines.join('\n')
            echo "âœ… Ã‰tat texte sauvegardÃ© dans ${env.BUILD_STATE_FILE}"
          }
        }
      }
    }
  }

  post {
    failure {
      echo "âŒ Pipeline orchestrateur Ã©chouÃ©."
    }

    always {
      archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
      echo "ğŸ“ RÃ©sumÃ© des builds :"
      script {
        if (buildResults) {
          buildResults.each { service, result ->
            echo "ğŸ” ${service} : ${result}"
          }

          def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
          def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
          def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }

          echo "ğŸ“Š TOTAL: ${buildResults.size()}, SUCCÃˆS: ${successCount}, Ã‰CHECS: ${failureCount}, ABANDONNÃ‰S: ${abortedCount}"
        } else {
          echo "â„¹ï¸ Aucun rÃ©sultat de build Ã  afficher."
        }

        if (fileExists(env.BUILD_STATE_FILE)) {
          echo "ğŸ“‚ Contenu du fichier d'Ã©tat texte :"
          echo readFile(env.BUILD_STATE_FILE)
        }
      }
    }
  }
}
