pipeline {
  agent any
  environment {
    DOCKERHUB_CREDENTIALS = 'dockerhub-credentials'
    DOCKERHUB_REPO = 'hamidbong/webapp'
  }
  parameters {
    choice(name: 'SERVICE', choices: ['order-service', 'user-service'], description: 'Sélectionnez le microservice à builder')
  }
  stages {
    stage('Checkout') {
      steps {
        script {
          checkout scm
        }
      }
    }

    stage('Checkout & Détection des changements') {
            steps {
                script {  // <-- Bloc script obligatoire pour les fonctions personnalisées
                    def changes = getGitChanges()  // Appel de la fonction
                    env.MODIFIED_SERVICES = detectModifiedServices(changes)
                }
            }
        }

    stage('Préparation') {
            steps {
                script {
                    // Détection des changements dans chaque microservice
                    CHANGED_SERVICES = []

                    // Vérifie chaque répertoire pour voir s’il y a eu des changements
                    def services = ['order-service', 'user-service']
                    for (service in services) {
                        def changes = sh(script: "git diff --name-only origin/main...HEAD ${service}", returnStdout: true).trim()
                        if (changes) {
                            CHANGED_SERVICES.add(service)
                        }
                    }

                    // Log des services modifiés
                    echo "Services modifiés : ${CHANGED_SERVICES}"
                }
            }
        }
    stage('Build') {
      steps {
        script {
          if (params.SERVICE == 'order-service') {
            dir('order-service') {
              sh 'npm install'
              sh 'npm run build'
            }
          } else if (params.SERVICE == 'user-service') {
            dir('user-service') {
              sh 'mvn clean package'
            }
          }
        }
      }
    }

    stage('Test') {
      steps {
        script {
          if (params.SERVICE == 'order-service') {
            dir('order-service') {
              sh 'npm test'
            }
          } else if (params.SERVICE == 'user-service') {
            dir('service-java') {
              sh 'mvn test'
            }
          }
        }
      }
    }

    stage('Security Scan') {
      agent {
        docker {
          image 'aquasec/trivy:latest'
          args '-v /var/run/docker.sock:/var/run/docker.sock'
        }
      }
      steps {
        script {
          def imageTag = "${DOCKERHUB_REPO}:${env.SERVICE}-${env.BUILD_NUMBER}"
          sh "docker build -t ${imageTag} ."
          sh "trivy image ${imageTag} || true"
        }
      }
    }

    stage('Docker Build & Push') {
      steps {
        script {
          def imageTag = "${DOCKERHUB_REPO}:${env.SERVICE}-${env.BUILD_NUMBER}"

          docker.withRegistry('https://index.docker.io/v1/', "${DOCKERHUB_CREDENTIALS}") {
            dir("${env.SERVICE}") {
              sh "docker build -t ${imageTag} ."
              sh "docker push ${imageTag}"
            }
          }
          echo "Image poussée : ${imageTag}"
        }
      }
    }

    stage('Deploy') {
      steps {
        script {
          withCredentials([file(credentialsId: 'KUBECONFIG_PROD', variable: 'KUBECONFIG')]) {
            sh """
              export KUBECONFIG=$KUBECONFIG
              helm upgrade --install ${params.SERVICE} ./helm-chart \
                --set image.repository=${DOCKER_REGISTRY}/${params.SERVICE} \
                --set image.tag=${IMAGE_TAG} \
                --namespace mynamespace \
                --kube-context=${KUBE_CONTEXT}
            """
          }
        }
      }
    }
  }
  post {
    always {
      cleanWs()
    }
  }
}
