def buildResults = [:]

pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
  }
  stages {
    stage('V√©rifications Initiales') {
      steps {
        script {
          echo "üîç V√©rification des variables d'environnement"
          echo "BRANCH_NAME: ${env.BRANCH_NAME ?: 'NON D√âFINI'}"
          echo "WORKSPACE: ${env.WORKSPACE ?: 'NON D√âFINI'}"
      
          if (!env.BRANCH_NAME) {
            error("La variable BRANCH_NAME n'est pas d√©finie!")
          }
        }
      }
    }
    stage('Pr√©paration') {
      steps {
        script {
          env.STATE_FILE = ".failed_services_${env.BRANCH_NAME}.txt"
          

          buildResults.clear()

          def changedFiles = []
          try {
            changedFiles = sh(
              script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
              returnStdout: true
            ).trim().split('\n')
          } catch (Exception e) {
            echo "‚ö†Ô∏è Impossible de d√©tecter les changements: ${e.message}"
          }

          echo "üîç Fichiers modifi√©s : ${changedFiles}"

          def services = env.SERVICES.split(',').collect { it.trim() } as Set

          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set

          def failedServices = [] as Set
          if (fileExists(env.STATE_FILE)) {
            failedServices = readFile(env.STATE_FILE).split('\n')
              .collect { it.trim() }
              .findAll { it } as Set
          }

          def allServicesToBuild = (affectedServices + failedServices).toList()

          echo "üöÄ Services √† builder : ${allServicesToBuild}"
          env.AFFECTED_SERVICES = allServicesToBuild.join(',')
        }
      }
    }

    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }

          servicesToBuild.each { service ->
            if (service) {
              echo "üöÄ D√©clenchement du job Jenkins pour ${service}"

              def buildResult = build job: "${service}/main",
                                       wait: true,
                                       propagate: false,
                                       parameters: []

              echo "üîé R√©sultat du job ${service} : ${buildResult.result}"
              buildResults[service] = buildResult.result
              if (buildResult.result == 'FAILURE') {
                addToFailedFile(service, env.STATE_FILE)
                echo "‚úÖ Ajout√© √† ${env.STATE_FILE} : ${service}"

                echo "üîé ${service} ajout√© au fichier des services √©chou√©s."
              } else {
                removeFromFailedFile(service, env.STATE_FILE)
              }
            }
          }
        }

        script {
          if (buildResults.values().any { it == 'FAILURE' }) {
            currentBuild.result = 'FAILURE'
            echo "‚ùå Des builds ont √©chou√©."
          }
        }
      }
    }
  }

  post {
    failure {
      echo "‚ùå Pipeline orchestrateur √©chou√©."
    }

    always {
      echo "üìù R√©sum√© des builds:"
      script {
        buildResults.each { service, result ->
          echo "üîé ${service} : ${result}"
        }
      }
    }
  }
}

// Fonctions utilitaires
/*def addToFailedFile(service, stateFile) {
  def failedServices = [] as Set
  if (fileExists(stateFile)) {
    failedServices = readFile(stateFile).split('\n')
      .collect { it.trim() }
      .findAll { it } as Set
  }
  if (!failedServices.contains(service)) {
    writeFile file: stateFile, text: (failedServices + service).toList().join('\n').trim()
  }
}*/
def addToFailedFile(service, stateFile) {
  try {
    echo "=== TENTATIVE D'AJOUT ==="
    echo "Service: ${service}"
    echo "Fichier: ${stateFile}"
    
    def failedServices = [] as Set
    if (fileExists(stateFile)) {
      echo "Fichier existant d√©tect√©, lecture..."
      def content = readFile(stateFile)
      echo "Contenu actuel: ${content}"
      failedServices = content.split('\n')
        .collect { it.trim() }
        .findAll { it } as Set
    } else {
      echo "Fichier n'existe pas encore, cr√©ation..."
    }
    
    if (!failedServices.contains(service)) {
      echo "Ajout du service ${service}"
      def newContent = (failedServices + service).toList().join('\n').trim()
      echo "Nouveau contenu: ${newContent}"
      writeFile file: stateFile, text: newContent
      echo "‚úÖ √âcriture r√©ussie"
    } else {
      echo "Service d√©j√† pr√©sent, pas d'ajout n√©cessaire"
    }
  } catch (Exception e) {
    echo "‚ùå ERREUR CRITIQUE: ${e.getClass().getName()}"
    echo "Message: ${e.message}"
    echo "Stack trace:"
    e.printStackTrace()
    error("√âchec de l'ajout au fichier")
  }
}

def removeFromFailedFile(service, stateFile) {
  if (fileExists(stateFile)) {
    def failedServices = readFile(stateFile).split('\n')
      .collect { it.trim() }
      .findAll { it } as Set
    failedServices = failedServices - service
    writeFile file: stateFile, text: failedServices.toList().join('\n').trim()
  }
}
