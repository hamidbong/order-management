def buildResults = [:]
def buildState = [:]

pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    BUILD_STATE_FILE = '.build-state.json'
  }
  
  stages {
    stage('PrÃ©paration') {
      steps {
        script {
          // ðŸŸ¡ Restaurer le fichier d'Ã©tat du dernier build rÃ©ussi
          try {
            step([
              $class: 'CopyArtifact',
              projectName: env.JOB_NAME,
              selector: lastSuccessful(),
              filter: env.BUILD_STATE_FILE,
              target: '.',
              flatten: true
            ])
            echo "âœ… Artefact rÃ©cupÃ©rÃ© avec succÃ¨s"
          } catch (Exception e) {
            echo "âš ï¸ Impossible de restaurer l'artefact : ${e.message}"
          }
          
          // Initialiser buildState avec la structure de base
          buildState = [
            branch: env.BRANCH_NAME,
            buildNumber: env.BUILD_NUMBER,
            buildUrl: env.BUILD_URL,
            timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
            services: [:],
            previousState: [:]  // Initialiser explicitement comme objet vide
          ]
          
          // Charger l'Ã©tat prÃ©cÃ©dent avec une gestion plus robuste
          if (fileExists(env.BUILD_STATE_FILE)) {
            try {
              def previousContent = readFile(env.BUILD_STATE_FILE).trim()
              
              if (previousContent && !previousContent.allWhitespace) {
                echo "Contenu du fichier prÃ©cÃ©dent:\n${previousContent}"
                // Conversion explicite en Map
                def parsedContent = new groovy.json.JsonSlurper().parseText(previousContent) as Map
                
                if (parsedContent && !parsedContent.isEmpty()) {
                  buildState.previousState = parsedContent ?: [:]
                  echo "âœ… Ã‰tat prÃ©cÃ©dent chargÃ© avec succÃ¨s"
                } else {
                  echo "âš ï¸ Fichier JSON parsÃ© mais vide"
                  buildState.previousState = [:]
                }
              } else {
                echo "âš ï¸ Fichier d'Ã©tat existant mais vide ou ne contenant que des espaces"
                buildState.previousState = [:]
              }
            } catch (Exception e) {
              echo "âš ï¸ Erreur lors du parsing du fichier d'Ã©tat: ${e.getMessage()}"
              buildState.previousState = [:]
            }
          } else {
            echo "â„¹ï¸ Aucun fichier d'Ã©tat prÃ©cÃ©dent trouvÃ© (${env.BUILD_STATE_FILE})"
            buildState.previousState = [:]
          }
          
          // DÃ©tection des changements
          def changedFiles = []
          try {
            changedFiles = sh(
              script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
              returnStdout: true
            ).trim().split('\n')
          } catch (Exception e) {
            echo "âš ï¸ Impossible de dÃ©tecter les changements: ${e.message}"
          }

          echo "ðŸ” Fichiers modifiÃ©s : ${changedFiles}"

          def services = env.SERVICES.split(',').collect { it.trim() } as Set
          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set

          // Ajouter les services prÃ©cÃ©demment en Ã©chec
          if (buildState.previousState?.services) {
            def previouslyFailed = buildState.previousState.services.findAll { 
              k, v -> v.status == 'FAILURE' 
            }.keySet()
            affectedServices.addAll(previouslyFailed)
          }

          echo "ðŸš€ Services Ã  builder : ${affectedServices}"
          env.AFFECTED_SERVICES = affectedServices.join(',')
        

          // DÃ©tection des changements avec gestion robuste
          /*def changedFiles = []
          try {
            // MÃ©thode plus fiable pour obtenir les commits
            def gitPrevious = sh(script: 'git rev-parse HEAD~1', returnStdout: true).trim()
            def gitCurrent = sh(script: 'git rev-parse HEAD', returnStdout: true).trim()
            
            changedFiles = sh(
              script: "git diff --name-only ${gitPrevious} ${gitCurrent}",
              returnStdout: true
            ).trim().split('\n').findAll { it.trim().length() > 0 }
            
            echo "ðŸ” Fichiers modifiÃ©s : ${changedFiles}"
          } catch (Exception e) {
            echo "âš ï¸ Impossible de dÃ©tecter les changements: ${e.message}"
            changedFiles = []
          }

          // DÃ©tection des services affectÃ©s
          def services = env.SERVICES.split(',').collect { it.trim() } as Set
          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set

          // Ajouter les services prÃ©cÃ©demment en Ã©chec
          if (buildState.previousState?.services instanceof Map) {
            def previouslyFailed = buildState.previousState.services.findAll { 
              k, v -> v?.status == 'FAILURE' 
            }.keySet()
            affectedServices.addAll(previouslyFailed)
          }

          echo "ðŸš€ Services Ã  builder : ${affectedServices}"
          env.AFFECTED_SERVICES = affectedServices.join(',')
        }*/
        }
      }
    }

    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }.findAll { it }

          if (servicesToBuild.isEmpty()) {
            echo "â„¹ï¸ Aucun service Ã  builder - skip"
          } else {
            servicesToBuild.each { service ->
              echo "ðŸš€ DÃ©clenchement du job Jenkins pour ${service}"

              def buildResult = build job: "${service}/main",
                                   wait: true,
                                   propagate: false,
                                   parameters: []

              echo "ðŸ”Ž RÃ©sultat du job ${service} : ${buildResult.result}"
              
              // Enregistrer le rÃ©sultat
              buildResults[service] = buildResult.result
              buildState.services[service] = [
                status: buildResult.result,
                buildNumber: buildResult.number,
                buildUrl: buildResult.absoluteUrl,
                timestamp: new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
              ]
            }
          }
          
          // Ã‰crire le fichier d'Ã©tat avec vÃ©rification
          try {
            def jsonContent = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(buildState))
            writeFile file: env.BUILD_STATE_FILE, text: jsonContent
            echo "âœ… Ã‰tat du build sauvegardÃ© dans ${env.BUILD_STATE_FILE}"
          } catch (Exception e) {
            echo "âŒ Erreur lors de l'Ã©criture du fichier d'Ã©tat: ${e.getMessage()}"
          }
        }
      }
    }
  }

  post {
    failure {
      echo "âŒ Pipeline orchestrateur Ã©chouÃ©."
    }

    always {
      // Archive le fichier d'Ã©tat comme artefact
      archiveArtifacts artifacts: env.BUILD_STATE_FILE, fingerprint: true
      
      // Affichage du rÃ©sumÃ©
      echo "ðŸ“ RÃ©sumÃ© des builds:"
      script {
        buildResults.each { service, result ->
          echo "ðŸ”Ž ${service} : ${result}"
        }
        
        def successCount = buildResults.count { k, v -> v == 'SUCCESS' }
        def failureCount = buildResults.count { k, v -> v == 'FAILURE' }
        def abortedCount = buildResults.count { k, v -> v == 'ABORTED' }
        echo "ðŸ“Š TOTAL: ${buildResults.size()}, SUCCÃˆS: ${successCount}, Ã‰CHECS: ${failureCount}, ABANDONNÃ‰S: ${abortedCount}"
        
        // Afficher le contenu du fichier d'Ã©tat pour debug
        if (fileExists(env.BUILD_STATE_FILE)) {
          echo "Contenu du fichier d'Ã©tat:"
          echo readFile(env.BUILD_STATE_FILE)
        }
      }
    }
  }
}