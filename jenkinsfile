pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    STATE_FILE = '.build-state.json'
  }
  stages {
    stage('Pr√©paration') {
      steps {
        script {
          // Initialiser la liste des services modifi√©s
          def changedFiles = []
          try {
            changedFiles = sh(
              script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
              returnStdout: true
            ).trim().split('\n')
          } catch (Exception e) {
            echo "‚ö†Ô∏è Impossible de d√©tecter les changements: ${e.message}"
          }

          echo "üîç Fichiers modifi√©s : ${changedFiles}"

          // Convertir la liste des services en Set pour √©liminer les doublons
          def services = env.SERVICES.split(',').collect { it.trim() } as Set

          // D√©tecter les services affect√©s
          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set

          // Ajouter les services en √©chec
          def failedServices = [] as Set
          if (fileExists('failed_services.txt')) {
            failedServices = readFile('failed_services.txt').split('\n')
                          .collect { it.trim() }
                          .findAll { it } as Set // Supprime les lignes vides
          }

          // Combiner les listes en utilisant l'union de Sets
          def allServicesToBuild = (affectedServices + failedServices).toList()

          echo "üöÄ Services √† builder : ${allServicesToBuild}"
          env.AFFECTED_SERVICES = allServicesToBuild.join(',')
        }
      }
    }
    
    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }
          


          /*servicesToBuild.each { service ->
            if (service) { // V√©rifier que le nom n'est pas vide
              try {
                echo "üèóÔ∏è Building service: ${service}"
                build job: "build-${service}", wait: false
                removeFromFailedFile(service)
              } catch (Exception e) {
                echo "‚ùå √âchec du build pour ${service}: ${e.message}"
                addToFailedFile(service)
              }
            }
          }*/

          servicesToBuild.each { service ->
           if (service) {
            echo "üöÄ D√©clenchement du job Jenkins pour ${service}"

            def buildResult = build job: "${service}/main",
                                     wait: true,      // Attend la fin du build
                                     propagate: false, // Ne fait pas √©chouer directement le pipeline orchestrateur
                                     parameters: []    // Tu peux passer des param√®tres si besoin

            echo "üîé R√©sultat du job ${service} : ${buildResult.result}"
            buildResults[service] = buildResult.result
            if(buildResults[service] == 'FAILURE'){
              addToFailedFile(service)
              echo "üîé le job ${service} : ajout√© au fichier des services echou√©s, cause ${buildResult.result}"
            }
            else {
              removeFromFailedFile(service)
            }
           }
            
          }

        }
      }
    }
  }
    
  post {
    failure {
      echo "‚ùå Pipeline orchestrateur √©chou√©."
    }
    always {
      echo "üìù √âtat des builds:"
      script {
        if (fileExists('failed_services.txt')) {
          def failedServices = readFile('failed_services.txt')
          echo "Services en √©chec:\n${failedServices}"
        } else {
          echo "Aucun service en √©chec"
        }
      }
    }
  }
}

// Fonctions utilitaires
def addToFailedFile(service) {
    def failedServices = [] as Set
    if (fileExists('failed_services.txt')) {
        failedServices = readFile('failed_services.txt').split('\n')
                      .collect { it.trim() }
                      .findAll { it } as Set
    }
    if (!failedServices.contains(service)) {
        writeFile file: 'failed_services.txt', text: (failedServices + service).toList().join('\n').trim()
    }
}

def removeFromFailedFile(service) {
    if (fileExists('failed_services.txt')) {
        def failedServices = readFile('failed_services.txt').split('\n')
                      .collect { it.trim() }
                      .findAll { it } as Set
        failedServices = failedServices - service
        writeFile file: 'failed_services.txt', text: failedServices.toList().join('\n').trim()
    }
}