def buildResults = [:]

pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    env.STATE_FILE = ".failed_services_main.txt"
  }
  stages {
    stage('PrÃ©paration') {
      steps {
        script {
          //env.STATE_FILE = ".failed_services_${env.BRANCH_NAME}.txt"
          

          buildResults.clear()

          def changedFiles = []
          try {
            changedFiles = sh(
              script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
              returnStdout: true
            ).trim().split('\n')
          } catch (Exception e) {
            echo "âš ï¸ Impossible de dÃ©tecter les changements: ${e.message}"
          }

          echo "ðŸ” Fichiers modifiÃ©s : ${changedFiles}"

          def services = env.SERVICES.split(',').collect { it.trim() } as Set

          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          } as Set

          def failedServices = [] as Set
          if (fileExists(env.STATE_FILE)) {
            failedServices = readFile(env.STATE_FILE).split('\n')
              .collect { it.trim() }
              .findAll { it } as Set
          }

          def allServicesToBuild = (affectedServices + failedServices).toList()

          echo "ðŸš€ Services Ã  builder : ${allServicesToBuild}"
          env.AFFECTED_SERVICES = allServicesToBuild.join(',')
        }
      }
    }

    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').collect { it.trim() }

          servicesToBuild.each { service ->
            if (service) {
              echo "ðŸš€ DÃ©clenchement du job Jenkins pour ${service}"

              def buildResult = build job: "${service}/main",
                                       wait: true,
                                       propagate: false,
                                       parameters: []

              echo "ðŸ”Ž RÃ©sultat du job ${service} : ${buildResult.result}"
              buildResults[service] = buildResult.result
              if (buildResult.result == 'FAILURE') {
                addToFailedFile(service, env.STATE_FILE)
                echo "ðŸ”Ž ${service} ajoutÃ© au fichier des services Ã©chouÃ©s."
              } else {
                removeFromFailedFile(service, env.STATE_FILE)
              }
            }
          }
        }

        script {
          if (buildResults.values().any { it == 'FAILURE' }) {
            currentBuild.result = 'FAILURE'
            echo "âŒ Des builds ont Ã©chouÃ©."
          }
        }
      }
    }
  }

  post {
    failure {
      echo "âŒ Pipeline orchestrateur Ã©chouÃ©."
    }

    always {
      echo "ðŸ“ RÃ©sumÃ© des builds:"
      script {
        buildResults.each { service, result ->
          echo "ðŸ”Ž ${service} : ${result}"
        }
      }
    }
  }
}

// Fonctions utilitaires
def addToFailedFile(service, stateFile) {
  echo "ðŸ”Ž ${service} est le service qui a echouÃ©."
  def failedServices = [] as Set
  if (fileExists(stateFile)) {
    failedServices = readFile(stateFile).split('\n')
      .collect { it.trim() }
      .findAll { it } as Set
  }
  if (!failedServices.contains(service)) {
    writeFile file: stateFile, text: (failedServices + service).toList().join('\n').trim()
  }
}

def removeFromFailedFile(service, stateFile) {
  if (fileExists(stateFile)) {
    def failedServices = readFile(stateFile).split('\n')
      .collect { it.trim() }
      .findAll { it } as Set
    failedServices = failedServices - service
    writeFile file: stateFile, text: failedServices.toList().join('\n').trim()
  }
}
