pipeline {
  agent any
  environment {
    SERVICES = 'order-service,user-service'
    STATE_FILE = '.build-state.json'
  }
  stages {
    stage('Pr√©paration') {
      steps {
        script {
          // Initialiser la liste des services modifi√©s
          def changedFiles = []
          try {
            changedFiles = sh(
              script: "git diff --name-only ${env.GIT_PREVIOUS_COMMIT} ${env.GIT_COMMIT}",
              returnStdout: true
            ).trim().split('\n')
          } catch (Exception e) {
            echo "‚ö†Ô∏è Impossible de d√©tecter les changements: ${e.message}"
          }

          echo "üîç Fichiers modifi√©s : ${changedFiles}"

          // Convertir la liste des services en List Groovy
          def services = env.SERVICES.split(',').toList()

          // D√©tecter les services affect√©s
          def affectedServices = services.findAll { service ->
            changedFiles.any { file -> file.startsWith("${service}/") }
          }

          // Ajouter les services en √©chec
          def failedServices = []
          if (fileExists('failed_services.txt')) {
            failedServices = readFile('failed_services.txt').split('\n').toList()
            failedServices.removeAll { it.trim().isEmpty() } // Nettoyer les lignes vides
          }

          // Combiner les listes et √©liminer les doublons
          def allServicesToBuild = (affectedServices + failedServices).toUnique()

          echo "üöÄ Services √† builder : ${allServicesToBuild}"
          env.AFFECTED_SERVICES = allServicesToBuild.join(',')
        }
      }
    }
    
    stage('Build Microservices') {
      steps {
        script {
          def servicesToBuild = env.AFFECTED_SERVICES.split(',').toList()
          
          servicesToBuild.each { service ->
            service = service.trim() // Nettoyer les espaces
            if (service) { // V√©rifier que le nom n'est pas vide
              try {
                echo "üèóÔ∏è Building service: ${service}"
                build job: "build-${service}", wait: false
                removeFromFailedFile(service)
              } catch (Exception e) {
                echo "‚ùå √âchec du build pour ${service}: ${e.message}"
                addToFailedFile(service)
              }
            }
          }
        }
      }
    }
  }
    
  post {
    failure {
      echo "‚ùå Pipeline orchestrateur √©chou√©."
    }
    always {
      echo "üìù √âtat des builds:"
      script {
        if (fileExists('failed_services.txt')) {
          def failedServices = readFile('failed_services.txt')
          echo "Services en √©chec:\n${failedServices}"
        } else {
          echo "Aucun service en √©chec"
        }
      }
    }
  }
}

// Fonctions utilitaires
def addToFailedFile(service) {
    def failedServices = []
    if (fileExists('failed_services.txt')) {
        failedServices = readFile('failed_services.txt').split('\n').toList()
        failedServices.removeAll { it.trim().isEmpty() } // Nettoyer les lignes vides
    }
    if (!failedServices.contains(service)) {
        writeFile file: 'failed_services.txt', text: "${failedServices.join('\n')}\n${service}".trim()
    }
}

def removeFromFailedFile(service) {
    if (fileExists('failed_services.txt')) {
        def failedServices = readFile('failed_services.txt').split('\n').toList()
        failedServices.removeAll { it.trim().isEmpty() } // Nettoyer les lignes vides
        failedServices = failedServices - service
        writeFile file: 'failed_services.txt', text: failedServices.join('\n').trim()
    }
}